{"meta":{"title":"지혁's Blog","subtitle":"공부한거 기록하는 블로그","description":"","author":"Jihyuk Jung","url":"http://jungjihyuk.github.io","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-02-22T07:35:20.629Z","updated":"2020-02-22T07:35:20.630Z","comments":true,"path":"2020/02/22/hello-world/","link":"","permalink":"http://jungjihyuk.github.io/2020/02/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Helper Function for Clean code (Python)","slug":"python-skills","date":"2020-02-03T15:00:00.000Z","updated":"2020-02-16T05:18:25.270Z","comments":true,"path":"2020/02/04/python-skills/","link":"","permalink":"http://jungjihyuk.github.io/2020/02/04/python-skills/","excerpt":"파이썬 코딩의 기술 책 Better way 4 정리","text":"Python 코드의 가독성을 높여보자 #상황 1. URL에서 쿼리 문자열을 디코드해야 할 때 URL에서 인코딩, 디코딩의 의미는 보안에서의 의미와 살짝 다르다. 인코딩 http://www.google.com/떡볶이 먹고싶다!! =&gt; http://www.google.com/search?sxsrf=ACYBGNTgapWszfC06soR1IlVyLsC2w_7EQ% 3A1580777854450&amp;source=hp&amp;ei=fsE4Xri1GdWRr7wPvM2UOA&amp;q=떡볶이+먹고싶다!! 주소에 한글/공백/특수기호가 들어가면 안되기 때문에 가능하도록 변환하는 작업 디코딩은 그 반대 Boolean 표현식123456789101112from urllib.parse import parse_qsmy_values = parse_qs('red=5&amp;blue=0&amp;green=',keep_blank_values=True)# 값 전체 (dictionary로 저장)print(my_values): &#123;'red': ['5'], 'green':[''],'blue':['0']&#125;# 각각의 값을 뽑을 때red = my_values.get('red',[''])[0] or 0green = my_values.get('green',[''])[0] or 0opacity = my_values.get('opacity',[''])[0] or 0 평가 =&gt; 이 표현식은 읽기도 불편하고 필요한 작업을 수행하지도 못하는 좋지 못한 코딩{: .notice} Boolean 표현식 변형12345678red = my_values.get('red',[''])[0] or 0green = my_values.get('green',[''])[0] or 0opacity = my_values.get('opacity',[''])[0] or 0 ∥ ∨red = int(my_values.get('red',[''])[0] or 0)green = int(my_values.get('green',[''])[0] or 0)opacity = int(my_values.get('opacity',[''])[0] or 0) if/else 조건식(삼항 표현식)123456789101112from urllib.parse import parse_qsmy_values = parse_qs('red=5&amp;blue=0&amp;green=',keep_blank_values=True)red = my_values.get('red',[''])red = int(red[0]) if red[0] else 0green = my_values.get('green',[''])green = int(green[0]) if green[0] else 0opacity = my_values.get('opacity',[''])opacity = int(opacity[0]) if opacity[0] else 0 평가 =&gt; 삼항 표현식은 코드를 짧게 유지하면서도 명확하게 표현 할 수 있는 장점이 있지만 복잡한 로직일 경우 남발하면 안된다.{: .notice} 여러줄에 걸친 if/else 문1234567891011121314151617green = my_values.get('green',[''])if green[0]: green = int(green[0])else: green = 0red = my_values.get('red',[''])if red[0]: red = int(red[0])else: red = 0opacity = my_values.get('opacity',[''])if opacity[0]: opacity = int(opacity[0])else: opacity = 0 평가 =&gt; 직관적이고 이해하기 편하나 코드의 길이가 길어 속도가 느려질 수 있다. 그리고 오히려 복잡한 수학 문제 같은 경우 코드가 길면 이해하기 더 힘들 수 있다.{: .notice} Helper Function1234567891011 def get_first_int(values, key, default=0): found = values.get(key, ['']) if found[0]: found = int(found[0]) else: found = default return foundgreen = get_first_int(my_values, 'green')red = get_first_int(my_values, 'red')opacity = get_first_int(my_values, 'opacity') 평가 =&gt; 복잡한 표현식보다 호출 코드가 훨씬 명확해진다. 하지만 아주 간단한 문제인데도 불구하고 너무 헬퍼 함수를 쓰는 것도 그리 좋지 않다.{: .notice} 최종 평가 123456상황에 잘 맞게 적절하게 코드를 짜야 한다!그리고표현식이 복잡해지기 시작하면 최대한 빨리 해당 표현식을 작은 조각으로 분할하고로직을 헬퍼 함수로 옮기는 방안을 고려해야 한다.무조건 짧은 코드를 만들기보다는 가독성을 선택하는 편이 나을때가 많다.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://jungjihyuk.github.io/tags/python/"},{"name":"clean code","slug":"clean-code","permalink":"http://jungjihyuk.github.io/tags/clean-code/"},{"name":"helper function","slug":"helper-function","permalink":"http://jungjihyuk.github.io/tags/helper-function/"}]}]}