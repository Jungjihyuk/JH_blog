{"meta":{"title":"지혁's Blog","subtitle":"공부한거 기록하는 블로그","description":"","author":"Jihyuk Jung","url":"http://jungjihyuk.github.io","root":"/"},"pages":[{"title":"projects","date":"2020-02-23T07:16:00.000Z","updated":"2020-02-23T07:16:00.620Z","comments":true,"path":"projects/index.html","permalink":"http://jungjihyuk.github.io/projects/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-02-22T07:35:20.629Z","updated":"2020-02-22T07:35:20.630Z","comments":true,"path":"2020/02/22/hello-world/","link":"","permalink":"http://jungjihyuk.github.io/2020/02/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Helper Function for Clean code (Python)","slug":"python-skills","date":"2020-02-03T15:00:00.000Z","updated":"2020-02-23T08:14:31.876Z","comments":true,"path":"2020/02/04/python-skills/","link":"","permalink":"http://jungjihyuk.github.io/2020/02/04/python-skills/","excerpt":"파이썬 코딩의 기술 책 Better way 4 정리","text":"Python 코드의 가독성을 높여보자 #상황 1. URL에서 쿼리 문자열을 디코드해야 할 때 URL에서 인코딩, 디코딩의 의미는 보안에서의 의미와 살짝 다르다. 인코딩 http://www.google.com/떡볶이 먹고싶다!! =&gt; http://www.google.com/search?sxsrf=ACYBGNTgapWszfC06soR1IlVyLsC2w_7EQ% 3A1580777854450&amp;source=hp&amp;ei=fsE4Xri1GdWRr7wPvM2UOA&amp;q=떡볶이+먹고싶다!! 주소에 한글/공백/특수기호가 들어가면 안되기 때문에 가능하도록 변환하는 작업 디코딩은 그 반대 Boolean 표현식123456789101112from urllib.parse import parse_qsmy_values = parse_qs('red=5&amp;blue=0&amp;green=',keep_blank_values=True)# 값 전체 (dictionary로 저장)print(my_values): &#123;'red': ['5'], 'green':[''],'blue':['0']&#125;# 각각의 값을 뽑을 때red = my_values.get('red',[''])[0] or 0green = my_values.get('green',[''])[0] or 0opacity = my_values.get('opacity',[''])[0] or 0 평가 =&gt; 이 표현식은 읽기도 불편하고 필요한 작업을 수행하지도 못하는 좋지 못한 코딩 Boolean 표현식 변형12345678red = my_values.get('red',[''])[0] or 0green = my_values.get('green',[''])[0] or 0opacity = my_values.get('opacity',[''])[0] or 0 ∥ ∨red = int(my_values.get('red',[''])[0] or 0)green = int(my_values.get('green',[''])[0] or 0)opacity = int(my_values.get('opacity',[''])[0] or 0) if/else 조건식(삼항 표현식)123456789101112from urllib.parse import parse_qsmy_values = parse_qs('red=5&amp;blue=0&amp;green=',keep_blank_values=True)red = my_values.get('red',[''])red = int(red[0]) if red[0] else 0green = my_values.get('green',[''])green = int(green[0]) if green[0] else 0opacity = my_values.get('opacity',[''])opacity = int(opacity[0]) if opacity[0] else 0 평가 =&gt; 삼항 표현식은 코드를 짧게 유지하면서도 명확하게 표현 할 수 있는 장점이 있지만 복잡한 로직일 경우 남발하면 안된다. 여러줄에 걸친 if/else 문1234567891011121314151617green = my_values.get('green',[''])if green[0]: green = int(green[0])else: green = 0red = my_values.get('red',[''])if red[0]: red = int(red[0])else: red = 0opacity = my_values.get('opacity',[''])if opacity[0]: opacity = int(opacity[0])else: opacity = 0 평가 =&gt; 직관적이고 이해하기 편하나 코드의 길이가 길어 속도가 느려질 수 있다. 그리고 오히려 복잡한 수학 문제 같은 경우 코드가 길면 이해하기 더 힘들 수 있다. Helper Function1234567891011 def get_first_int(values, key, default=0): found = values.get(key, ['']) if found[0]: found = int(found[0]) else: found = default return foundgreen = get_first_int(my_values, 'green')red = get_first_int(my_values, 'red')opacity = get_first_int(my_values, 'opacity') 평가 =&gt; 복잡한 표현식보다 호출 코드가 훨씬 명확해진다. 하지만 아주 간단한 문제인데도 불구하고 너무 헬퍼 함수를 쓰는 것도 그리 좋지 않다. 최종 평가 123456상황에 잘 맞게 적절하게 코드를 짜야 한다!그리고표현식이 복잡해지기 시작하면 최대한 빨리 해당 표현식을 작은 조각으로 분할하고로직을 헬퍼 함수로 옮기는 방안을 고려해야 한다.무조건 짧은 코드를 만들기보다는 가독성을 선택하는 편이 나을때가 많다.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://jungjihyuk.github.io/tags/python/"},{"name":"clean code","slug":"clean-code","permalink":"http://jungjihyuk.github.io/tags/clean-code/"},{"name":"helper function","slug":"helper-function","permalink":"http://jungjihyuk.github.io/tags/helper-function/"}]},{"title":"Yield와 send 함수를 알아보자 (Python)","slug":"python-yield-send","date":"2020-02-02T15:00:00.000Z","updated":"2020-02-16T05:18:25.264Z","comments":true,"path":"2020/02/03/python-yield-send/","link":"","permalink":"http://jungjihyuk.github.io/2020/02/03/python-yield-send/","excerpt":"generator yield와 send함수","text":"Generator의 yield와 send에 대해 알아보자! Generator, Yield, Send가 도대체 뭐야? 우선 Generator는 generator(iterator를 반환하기 위한 객체)를 생성해주는 함수! 그럼 iterator는 무엇이냐! iterator는 반복할 수 있는 객체의 요소를 리턴할 때 호출 한 시점에 값을 리턴하며 값을 지우고 그 상태를 유지해준다. 그러면 Yield는 무슨 관계가 있는데? yield는 generator를 만들때 함수 안에 yield를 삽입하면 yield를 만나는 순간 iterator 처럼 행동한다. Generator 작동 순서 Step 1: Generator 메소드 호출 (Generator 객체 생성)Step 2: 생성된 generator를 next함수로 호출Step 3: yield까지 실행Step 4: 첫번째 yield에서 중단(suspend)Step 5: 호출자에게 expression_list 값을 반환(return)Step 6: 중단된 지점에서 모든 상태가 보존(지역 변수들의 현재 연결들, 명령 포인터, 내부 연산 스택, 모든 예외처리)Step 7: 1~5 step 반복 ※ next함수 vs send함수 next함수를 통해 호출되면 return은 None, send함수를 통해 호출되면 return은 메소드로 전달된 값{: .notice} Generator랑 Coroutine과의 관계는? 둘이 같은건가? 우선 컴퓨터 프로그램에서 routine이라는 말을 자주 찾아 볼 수 있는데, 이때의 routine은 “어떤 일을 담당하는 하나의 정리된 일” 이라고 한다.프로그램은 여러가지 routine을 조합하여 만들어지며, main routine과 sub routine으로 나눌 수 있다. main routine은 프로그램의 주요한 부분이고 전체의 개략적인 동작 절차를 표시하도록 만들어진다. sub routine은 사용빈도가 높고 자주 사용하는 부분을 모아 별도로 묶어 놓은 것으로 메인루틴을 보조한다. (메소로 묶음)(서브루틴을 사용하면 함수호출시에만 저장된 메모리로 이동하기 때문에 메모리를 효율적으로 사용할 수 있다)이제 진짜로 알아보려고 했던 Co-routine은 sub-routine과 비슷하다. 자주 쓰는 기능들을 별도의 공간에 모아 두었다는 점에서 서브루틴과 동일하지만, 코루틴은 yield까지 수행하고 상태를 중지한 후메인루틴으로 돌아가 마치 동시에 실행되는 것처럼 작동한다. (co에서 볼 수 있듯 메인루틴과 협력관계임)따라서 코루틴은 메인루틴에 종속적이지 않아 데이터를 주고 받을 수 있다! (이러한 특성때문에 send가 가능한 것임) 결국 Generator로 생성된 generator객체(iterator)는 co-routine과 같은 역할을 한다고 보면된다! Example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788def double(number): while True: number *= 2 yield number d = double(3)d.send(None) # 처음에 왜 None을 넣어야 모르겠음 .... ㅠㅠ : 6 d.send(1): 12 d.send(10): 24 def double2(number): while True: number *= 2 number = yield number d2 = double2(4) d2.send(None): 8d2.send(1): 2d2.send(100): 200def check1(): while True: x = yield yield x == numbernumber = 123 c1 = check1()c1.send(None)c1.send(123): Truec1.send(None)c1.send(1234): False def check2(): x = yield yield x == number2number2 = 1234 c2 = check2() c2.send(None)c2.send(1234):True c2.send(1234) : StopIterationdef check3(): yield (yield) == number3 number3 = 2c3 = check3()c3.send(None) c3.send(123): False c3.send(2): StopIteration def check4(): while True: yield (yield) == number4number4 = 777c4 = check4()c4.send(None) c4.send(123): False c4.send(7777) # interger 객체 7777은 return 값이 None이기 때문에 None을 넣었을 때와 같음 c4.send(777) : Truefor x in range(4): n = c4.send(777) print(n): None True None True None 출처: co-routine, co-routine2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IT 용어","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://jungjihyuk.github.io/tags/python/"},{"name":"generator","slug":"generator","permalink":"http://jungjihyuk.github.io/tags/generator/"},{"name":"yield","slug":"yield","permalink":"http://jungjihyuk.github.io/tags/yield/"},{"name":"send","slug":"send","permalink":"http://jungjihyuk.github.io/tags/send/"}]}]}